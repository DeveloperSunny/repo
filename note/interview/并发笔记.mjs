高并发应对策略：

1. 采用有界的任务队列和不限个数的工作线程，这样可以平滑地处理高并发，不至于内存被撑爆
2. 单个线程请求时间必须要快，尽量不超过100ms
3. 如果单个线程处理的时间由于任务太大必须耗时，那么把任务拆个小任务来多次执行
4. 拆成小任务还是慢，那么把同步操作变成异步操作，即方法执行后立即返回，不要等待结果。由另一个线程异步地处理线程，比如采用单独的线程定时检查处理状态，或者采用异步回调的方式


出现的问题：队列的个数不可控制
	解决：
		1. 系统的吞吐量，比如1秒10万的吞吐量，可以观测一下峰值
		2.单个请求的处理时间，可以统计一下时间，可以采用不同的策略，比如一次请求完成就删除队列，或者等用户一次业务全部完成（多次请求）再删除队列




=========================================================================================================

单线程关注：结果正确性
多线程关注程序的活性：互斥性，无死锁，无饥饿

临界区使用方法：

		mutex.lock();
		try{
		 ...临界区
		}finally{
		    mutex.unlock()
		}

Amdahl定律: 即完成一个工作能获得的加速比，受限于这个工作中必须被串行的部分。

Amdahl给我们编程实际启示有：
	1. 尽量减小互斥锁的粒度，锁粒度越小表示串行的部分越少
	2. 能不用锁，就不要用锁。不用锁表示串行的部分越少



Peterson算法可以保证两个线程使用锁的时候锁具备互斥，无死锁，无饥饿特性

class Peterson implements Lock {
     private boolean[] flag = new boolean[2];
     private int victim;
     public void lock(){
           int i = ThreadID.get();
           int j = 1 - i;
           flag[i]= true;  // 保证两个线程先后运行不死锁，实现互斥 
           victim = i;  // 保证两个线程同时运行时不死锁，实现互斥
           while(flag[j] && victim == i){}  // 互斥意味着等待
     }

     public void unlock(){
           int i = ThreadID.get();
           flag[i] = false;
    }

}

Bakery锁支持n个线程的互斥协议。通过数学证明了：
n线程的无死锁互斥算法需要n个不同的存储单元（变量）来保存中间状态。



=========================================================================================================

栈帧->oop（堆区）->klass（常量区）

HSDB可以查看oop结构
			java -cp ${JAVA_HOME}/lib/sa-jdi.jar sun.jvm.hotspot.HSDB

=========================================================================================================